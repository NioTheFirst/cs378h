#!/usr/bin/env python3
"""
gen_icache_islands.py

the goal here is to generate large footprints that hopefully won't fit into the L1i.
unfortunately, I need hundreds of thousands of these thing, and I am not going to write it by hand.
so i have this handy python script that will generate a large c file with assembly blocks.

I had gpt help me do this.

generates an L1i measurement program that executes K "code islands".
each island:
  does a small fixed sequence of ALU work (real uops)
  then executes exactly a lot of nop instruction of varying length, to fill out the pad bytes variable

we sweep K (number of islands) to increase instruction footprint:
  footprint = K * (island_bytes + pad_bytes)

To use, first run the script:
  python3 gen_icache_islands.py --max_islands 4096 --pad_bytes 96 --out icache_islands.cc

Then, compile to c++
  g++ -O2 icache_islands.cc -o icache_islands

Pin to one core and run.
  taskset -c 0 ./icache_islands | tee icache_islands_out.txt
"""

import argparse

# Taken from the internet (https://grokipedia.com/page/NOP_(code)
# convert to raw bytes.
NOP_BYTES = [
    [0x90],                               # 1
    [0x66, 0x90],                         # 2
    [0x0F, 0x1F, 0x00],                   # 3
    [0x0F, 0x1F, 0x40, 0x00],             # 4
    [0x0F, 0x1F, 0x44, 0x00, 0x00],       # 5
    [0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00], # 6
    [0x0F, 0x1F, 0x80, 0x00,0x00,0x00,0x00], # 7
    [0x0F, 0x1F, 0x84, 0x00,0x00,0x00,0x00,0x00], # 8
    [0x66,0x0F,0x1F,0x84,0x00,0x00,0x00,0x00,0x00], # 9
]

#a filler function.
def emit_nop_pad(pad_bytes: int):
    """Return inline asm that emits exactly pad_bytes of varied-length NOPs."""
    out = []
    remaining = pad_bytes
    # At this point, I am too damn lazy to do it... use as many 9B NOPs as possible, then smaller.
	#This is problematic since the NOP might get compressed... hopefully it won't.
    while remaining > 0:
        for seq in reversed(NOP_BYTES):  # 9..1
            if len(seq) <= remaining:
                out.append(".byte " + ",".join(hex(b) for b in seq))
                remaining -= len(seq)
                break
	#reutrn me a string of this garbage nops
    return "\\n\\t".join(out)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--max_islands", type=int, default=4096,
                    help="Maximum islands generated (sets the largest sweep point).")
    ap.add_argument("--pad_bytes", type=int, default=96,
                    help="NOP padding bytes per island (controls footprint growth).")
    ap.add_argument("--out", type=str, default="icache_islands.cc")
    args = ap.parse_args()

	#how many k's and how many bytes
    Kmax = args.max_islands
    pad = args.pad_bytes

    if Kmax < 128:
        raise SystemExit("Use at least 128 max_islands; 1024â€“4096 recommended.")
    if pad < 0:
        raise SystemExit("pad_bytes must be >= 0")

    pad_asm = emit_nop_pad(pad)

    with open(args.out, "w") as f:
        f.write(f"""// {args.out}
// Generated by gen_icache_islands.py
//
// Build:
//   g++ -O2 {args.out} -o icache_islands
//
// Run:
//   taskset -c 0 ./icache_islands
//
// Output:
//   islands  pad_bytes  approx_footprint_bytes  cy/iter  cy/island
//
// Notes:
// - The following is code i have written for the base. It doesn't do much.

#include <cstdio>
#include <cstdint>
#include <x86intrin.h>

//my fence.
static inline uint64_t rdtsc_serialized() {{
  _mm_lfence();
  uint64_t t = __rdtsc();
  _mm_lfence();
  return t;
}}

//asm
static inline __attribute__((always_inline)) void island_work(volatile uint64_t &x) {{
  // Small ALU ops to keep things alive and keep x live.
  asm volatile(
    "add $1, %%rax\\n\\t"
    "xor %%rcx, %%rax\\n\\t"
    "lea (%%rax,%%rax,2), %%rax\\n\\t"
    "add $7, %%rax\\n\\t"
    : "+a"(x)
    :
    : "cc","rcx"
  );
}}

//asm
static inline __attribute__((always_inline)) void nop_pad() {{
  //nop stream. The outside code generates it.
  asm volatile(
    "{pad_asm}\\n\\t"
    ::: "memory"
  );
}}

//this is the main piece of code.
//generate a lot of gotos
__attribute__((noinline))
static uint64_t run_islands(int islands, int iters) {{
  static void* targets[{Kmax} + 1];
  volatile uint64_t x = 0x1234;

  if (islands < 2) islands = 2;
  if (islands > {Kmax}) islands = {Kmax};

  goto INIT;

""")
		# back to python.
        # Emit labels
        
        #this generates things like: 
            #L8:
            #   island_work(x);
            #   nop_pad();
            #   goto *targets[9];

            #L9:
            #   island_work(x);
            #   nop_pad();
            #   goto *targets[10];
        """
        for i in range(Kmax):
            f.write(f"L{i}:\n")
            f.write("  island_work(x);\n")
            if pad > 0:
                f.write("  nop_pad();\n")
            f.write(f"  goto *targets[{i+1}];\n\n")

        f.write("INIT:\n")
        for i in range(Kmax):
            f.write(f"  targets[{i}] = &&L{i};\n")
        f.write(r"""
  // Terminate after exactly 'islands' islands
  targets[islands] = &&ITER_DONE;

  const int warmup = 2000;
  uint64_t t0 = 0, t1 = 0;

  for (int it = -warmup; it < iters; ++it) {
    if (it == 0) t0 = rdtsc_serialized();

    goto *targets[0];

ITER_DONE:
    asm volatile("" : : "r"(x) : "memory");
    if (it == iters - 1) t1 = rdtsc_serialized();
  }

  return (t1 - t0);
}

int main() {
  const int iters = 50000;
  const int pad_bytes = """ + str(pad) + r""";

  std::puts("islands\tpad_bytes\tapprox_footprint_bytes\tcy/iter\tcy/island");

  for (int islands = 16; islands <= """ + str(Kmax) + r"""; islands *= 2) {
    uint64_t cyc = run_islands(islands, iters);
    double cy_per_iter = (double)cyc / (double)iters;
    double cy_per_island = cy_per_iter / (double)islands;

    // Approx footprint: each island has (work + pad). Work bytes vary by encoding,
    // so we estimate only by pad_bytes for the controlled part:
    long long approx = (long long)islands * (long long)pad_bytes;

    std::printf("%d\t%d\t%lld\t%.3f\t%.6f\n",
                islands, pad_bytes, approx, cy_per_iter, cy_per_island);
  }
  return 0;
}
""")

    print(f"Wrote {args.out} with max_islands={Kmax}, pad_bytes={pad}")

if __name__ == "__main__":
    main()
